clc; close all; clear variables;

DTvals = [0.1];
Nx = 120;
ERRORS = zeros(6, numel(DTvals));

for dtIndex = 1:numel(DTvals)
dt = DTvals(dtIndex);

% initial rank
r0 = 30;
% time-stepping method: 1=B.Euler, 2=DIRK2
method = '1';
tolerance = 1e-6;

ma = 1; % ion mass
me = 1/1836; % electron mass
qa = 1; % ion charge
qe = -1; % electron charge
R_const = 1; % gas constant

% IC parameters
alpha = 0.001; 
beta = 0.5;

% mesh parameters
Nr = 200;
Nz = 200;
x_min = 0;
x_max = 200;
interval = [x_min, x_max, 0, 9, -9, 9]; % 1D in x, 2D in v (x interval, r interval, z interval)
tf = 50;

% Meshes
[xvals, Rmat, Zmat, dx, dr, dz] = GetRZ(Nx, Nr, Nz, interval);

% IC
f0 = @(x) (1/((2*pi*R_const)^(3/2)))*(1+alpha*cos(beta*x)).*exp(-(Rmat.^2 + Zmat.^2)/2);
global n0_vals_IC u0_vals_IC T0_vals_IC;
n0_vals_IC = @(x) 2*pi*dr*dz*sum(sum(f0(x) .* Rmat));
u0_vals_IC = @(x) 2*pi*dr*dz*sum(sum(Zmat .* f0(x) .* Rmat))./n0_vals_IC(x);
T0_vals_IC = @(x) (2*pi*dr*dz*sum(sum((Rmat.^2 + Zmat.^2).*f0(x).*Rmat)) - n0_vals_IC(x)*u0_vals_IC(x)^2)/(3*n0_vals_IC(x)/ma);
n_IC = n0_vals_IC;
Te_IC = T0_vals_IC;

rvals = Rmat(:, 1);
zvals = Zmat(1, :)';
[Xmat, Zmat2] = meshgrid(xvals, zvals); Xmat=Xmat'; Zmat2=Zmat2'; % for plotting only

% initialize f and compute moments from f
f_vals = zeros(Nr, Nz, Nx);
n_vals = zeros(Nx, 1);
u_perp = zeros(Nx, 1);
u_para = zeros(Nx, 1);
Ta_vals = zeros(Nx, 1);
leftBC = []; rightBC = []; 
n_left_BC = 0; n_right_BC = 0;
u_left_BC = 0; u_right_BC = 0;
Ta_left_BC = 0; Ta_right_BC = 0;
for spatialIndex = 0:Nx+1
    if spatialIndex == 0
        x = x_min - dx/2;
    elseif spatialIndex == Nx+1
        x = x_max + dx/2;
    else
        x = xvals(spatialIndex);
    end
    f = f0(x);
    
    n = 2*pi*dr*dz*sum(sum(f .* Rmat));
    u = 2*pi*dr*dz*sum(sum(Zmat .* f .* Rmat))./n;
    Ta = (2*pi*dr*dz*sum(sum((Rmat.^2 + Zmat.^2).*f.*Rmat)) - n*u^2)/(3*n/ma);

    if spatialIndex == 0
        leftBC = f;
        n_left_BC = n;
        u_left_BC = u;
        Ta_left_BC = Ta;
    elseif spatialIndex == Nx+1
        rightBC = f;
        n_right_BC = n;
        u_right_BC = u;
        Ta_right_BC = Ta;
    else
        f_vals(:, :, spatialIndex) = f;
        n_vals(spatialIndex) = n;
        u_para(spatialIndex) = u;
        Ta_vals(spatialIndex) = Ta;
    end
end
Te_vals = Ta_vals;

U = 0.5*((3*Ta_vals/ma) + (u_para.^2));



tvals = [0, 5e-3:dt:tf]';
if tvals(end) ~= tf
    tvals = [tvals; tf];
end
Nt = numel(tvals);

Ar = @(u, w, t) w; %cell centers
Br = @(u, w, t) w.*(w - u); %evaluated on cell boundaries
Cr = @(u, w, t, T, m) (T/m)*w; %evaluated cell boundaries
Az = @(u, w, t) w.^0;
Bz = @(u, w, t) w - u;
Cz = @(u, w, t, T, m) (T/m)*w.^0;

% plot IC
% PlotF(f_vals_low_rank, Xmat, Rmat, Zmat2, Nz, 10)

% compute LoMaC parameters once
wr = exp(-(rvals.^2));
wz = exp(-(zvals.^2));
c = (dr*sum(rvals.^2.*wr.*rvals))/(dr*sum(wr.*rvals)) + (dz*sum(zvals.^2.*wz))/(dz*sum(wz));
w_norm_1_squared = 2*pi*dr*dz*sum(rvals .* wr)*sum(wz);
w_norm_v_squared = 2*pi*dr*dz*sum(rvals .* wr)*sum(zvals.^2 .* wz);
w_norm_v2_squared = 2*pi*dr*dz*sum(sum((Rmat.^2 + Zmat.^2 - c).^2 .* exp(-Rmat.^2 - Zmat.^2) .* Rmat));

% store rank, mass, momentum, energy, l1 decay, etc...
mass = zeros(Nt, 1);
momentum = zeros(Nt, 1);
energy = zeros(Nt, 1);
min_vals = zeros(Nt, 1);
avg_ranks = zeros(Nt, 1);
Efield = zeros(Nt, 1);

% used to recompute mass, momentum, energy after each time-step
n_vals_diff = zeros(Nx, 1);
u_vals_diff = zeros(Nx, 1);
Ta_vals_diff = zeros(Nx, 1);

% init bases
f_vals_low_rank = cell(Nx, 3); % store Vr, S, Vz at each spatial node
spatial_rank_vals = zeros(Nx, 1);
spatial_min_vals = zeros(Nx, 1);
spatial_Efield = zeros(Nx, 1);
for spatialIndex = 1:Nx
    f = f_vals(:, :, spatialIndex);
    [Vr, S, Vz] = svd2(f, rvals);
    r0 = min(r0, size(Vr, 2));
    Vr = Vr(:, 1:r0); S = S(1:r0, 1:r0); Vz = Vz(:, 1:r0);
    f_vals_low_rank{spatialIndex, 1} = Vr;
    f_vals_low_rank{spatialIndex, 2} = S;
    f_vals_low_rank{spatialIndex, 3} = Vz;  
    spatial_rank_vals(spatialIndex, 1) = r0;
    spatial_min_vals(spatialIndex, 1) = min(min(f));
    [~, E] = GetLorentz(dx, x_min, x_max, zvals, ma, qe, qa, n_vals, Te_vals, spatialIndex);
    spatial_Efield(spatialIndex, 1) = E;
end

mass(1) = dx*ma*sum(n_vals);
momentum(1) = dx*ma*sum(n_vals .* u_para);
energy(1) = dx*ma*sum(0.5*((3/ma)*n_vals.*Ta_vals + n_vals.*u_para.^2) + (3/2)*n_vals.*Te_vals);
min_vals(1) = min(spatial_min_vals);
avg_ranks(1) = mean(spatial_rank_vals);

flux_diff_n = 0;
flux_diff_nu = 0;
flux_diff_nU = 0;

% time-stepping loop
for t_index = 2:Nt
    tval = tvals(t_index);
    disp(tval);
    dt = tval - tvals(t_index-1);

    switch(method)
        case '1'
            [n_vals, u_para, Ta_vals, Te_vals, u_hat, nu_hat, S_hat, Q_hat, nTe_hat, kappaTx] = fluid_solver_IMEX111(f_vals_low_rank, n_vals, u_para, Ta_vals, Te_vals, dt, dx, dr, dz, Rmat, Zmat, qa, qe, ma, me, R_const, x_min, x_max);
            nu = n_vals .* u_para;
            nU = 0.5*((3/ma)*n_vals.*Ta_vals + n_vals.*u_para.^2);
        
            f_vals_low_rank_temp = cell(Nx, 3);
            f_vals_Vr = cell(Nx, 1);
            f_vals_S = cell(Nx, 1);
            f_vals_Vz = cell(Nx, 1);

        
            % if abs(tval - 1e-5) < dt || abs(tval - 200) < dt
            %     figure(1); clf;
            %     plot(xvals, n_vals, "LineWidth", 1.5); hold on;
            %     plot(xvals, u_para./u_para(1), "LineWidth",1.5);
            %     plot(xvals, Te_vals, "LineWidth", 1.5);
            %     plot(xvals, Ta_vals, "LineWidth", 1.5);
            %     legend('n', 'u_{||}', 'T_e', 'T_a');
            %     title(sprintf('Mass, momentum, ion temperature, and electron temperature at t=%s', num2str(tval)));
            %     ylim([0, 1.2]);
            %     saveas(gcf, sprintf('Plots/moments_time_%s.m', num2str(round(tval))));
            %     pause(0.05);
            % end
        
            parfor spatialIndex = 1:Nx
                Vr0 = f_vals_low_rank{spatialIndex, 1};
                S0 = f_vals_low_rank{spatialIndex, 2};
                Vz0 = f_vals_low_rank{spatialIndex, 3};
        
                rhoM = n_vals(spatialIndex);
                JzM  = nu(spatialIndex);
                kappaM = nU(spatialIndex);
                
                
                % [Vr, S, Vz, rank] = IMEX111(Vr, S, Vz, u_perp, u_para, dt, dx, tval, rvals, zvals, x_min, x_max, f_vals_low_rank, Rmat, Zmat, ma, me, qa, qe, Ar, Az, Br, Bz, Cr, Cz, tolerance, n_vals, Ta_vals, Te_vals, rhoM, JzM, kappaM, spatialIndex, R_const, leftBC, rightBC, wr, wz, c, w_norm_1_squared, w_norm_v_squared, w_norm_v2_squared);
                
                % discretize Fokker-Planck operators
                nu_aa = n_vals(spatialIndex)/(Ta_vals(spatialIndex)^(3/2));
                nu_ae = sqrt(2*me)*n_vals(spatialIndex)/(Te_vals(spatialIndex)^(3/2));
                C_aa_r1 = nu_aa*GetFokkerPlanckFlux(Ar, Br, Cr, u_perp(spatialIndex), Ta_vals(spatialIndex), ma, rvals, tval, dr);
                C_ae_r1 = nu_ae*GetFokkerPlanckFlux(Ar, Br, Cr, u_perp(spatialIndex), Te_vals(spatialIndex), ma, rvals, tval, dr);
                C_aa_z1 = nu_aa*GetFokkerPlanckFlux(Az, Bz, Cz, u_para(spatialIndex), Ta_vals(spatialIndex), ma, zvals, tval, dz);
                C_ae_z1 = nu_ae*GetFokkerPlanckFlux(Az, Bz, Cz, u_para(spatialIndex), Te_vals(spatialIndex), ma, zvals, tval, dz);
                Cr1 = C_aa_r1 + C_ae_r1;
                Cz1 = C_aa_z1 + C_ae_z1;
            
                % discretize Lorentz force
                [Dz1, E] = GetLorentz(dx, x_min, x_max, zvals, ma, qe, qa, n_vals, Te_vals, spatialIndex);
                spatial_Efield(spatialIndex) = E;

                % discretize velocity explicitly
                Dx1 = GetVlasov(dt, dx, Zmat, f_vals_low_rank, leftBC, rightBC, spatialIndex);
                W0 = (Vr0*S0*Vz0') - Dx1;
            
                Vr0_star = Vr0;
                Vz0_star = Vz0;
            
                K1 = sylvester(eye(Nr) - (dt*Cr1), dt*((Dz1 - Cz1)*Vz0_star)'*Vz0_star, W0*Vz0_star);
                L1 = sylvester(eye(Nz) + dt*(Dz1 - Cz1), -dt*(Cr1*Vr0_star)'*(rvals.*Vr0_star), W0'*(rvals .* Vr0_star));
                
                [Vr1_ddagger, ~] = qr2(K1, rvals);
                [Vz1_ddagger, ~] = qr(L1, 0);
            
                [Vr1_hat, Vz1_hat] = reduced_augmentation([Vr1_ddagger, Vr0], [Vz1_ddagger, Vz0], rvals);
            
                S1_hat = sylvester((eye(size(Vr1_hat, 2)) - (dt*((rvals .* Vr1_hat)')*(Cr1*Vr1_hat))), dt*((Dz1 - Cz1)*Vz1_hat)'*Vz1_hat, ((rvals .* Vr1_hat)'*W0*Vz1_hat));
                [Vr, S, Vz, rank] = LoMaC(Vr1_hat, S1_hat, Vz1_hat, Rmat, Zmat, rvals, zvals, tolerance, rhoM, JzM, kappaM, wr, wz, c, w_norm_1_squared, w_norm_v_squared, w_norm_v2_squared);


                % f_vals_low_rank_temp{spatialIndex, 1} = Vr;
                % f_vals_low_rank_temp{spatialIndex, 2} = S;
                % f_vals_low_rank_temp{spatialIndex, 3} = Vz;
                f_vals_Vr{spatialIndex} = Vr;
                f_vals_S{spatialIndex} = S;
                f_vals_Vz{spatialIndex} = Vz;

                f = Vr*S*Vz';
                spatial_rank_vals(spatialIndex, 1) = rank;
                spatial_min_vals(spatialIndex, 1) = min(min(f));
                n_vals_diff(spatialIndex) = 2*pi*dr*dz*sum(sum(f .* Rmat));
                u_vals_diff(spatialIndex) = 2*pi*dr*dz*sum(sum(Zmat .* f .* Rmat))./n_vals_diff(spatialIndex);
                Ta_vals_diff(spatialIndex) = (2*pi*dr*dz*sum(sum((Rmat.^2 + Zmat.^2).*f.*Rmat)) - n_vals_diff(spatialIndex)*u_vals_diff(spatialIndex)^2)/(3*n_vals_diff(spatialIndex)/ma);

            end

            % reassemble into cell array
            f_vals_low_rank_temp = [f_vals_Vr, f_vals_S, f_vals_Vz];

            % update mass, momentum, energy (IMEX111)
            flux_diff_n = flux_diff_n + dt*(nu_hat(end) - nu_hat(1));
            flux_diff_nu = flux_diff_nu + dt*((S_hat(end) - S_hat(1)) - (qa/(2*qe*ma))*(n_IC(x_max + dx/2)*Te_IC(x_max + dx/2) + n_vals(end)*Te_vals(end) - n_vals(1)*Te_vals(1) - n_IC(x_min - dx/2)*Te_IC(x_min - dx/2)));
            flux_diff_nU = flux_diff_nU + dt*((Q_hat(end) - Q_hat(1)) + 2.5*(u_hat(end)*nTe_hat(end) - u_hat(1)*nTe_hat(1)) - (kappaTx(end) - kappaTx(1)));
            
                    
        case '2' % IMEX222
            gamma = 1-(sqrt(2)/2);
            delta = 1-(1/(2*gamma));

            %%% STAGE 1 %%%
            [n_vals1, u_para1, Ta_vals1, Te_vals1, u_hat1, nu_hat1, S_hat1, Q_hat1, nTe_hat1, kappaTx1] = fluid_solver_IMEX111(f_vals_low_rank, n_vals, u_para, Ta_vals, Te_vals, gamma*dt, dx, dr, dz, Rmat, Zmat, qa, qe, ma, me, R_const, x_min, x_max);
            nu1 = n_vals1 .* u_para1;
            nU1 = 0.5*((3/ma)*n_vals1.*Ta_vals1 + n_vals1.*u_para1.^2);
        
            f_vals_low_rank_temp = cell(Nx, 3);
            f_vals_Vr = cell(Nx, 1);
            f_vals_S = cell(Nx, 1);
            f_vals_Vz = cell(Nx, 1);

            parfor spatialIndex = 1:Nx
                Vr0 = f_vals_low_rank{spatialIndex, 1};
                S0 = f_vals_low_rank{spatialIndex, 2};
                Vz0 = f_vals_low_rank{spatialIndex, 3};
        
                rhoM1 = n_vals1(spatialIndex);
                JzM1  = nu1(spatialIndex);
                kappaM1 = nU1(spatialIndex);
        
                dr = rvals(2) - rvals(1);
                dz = zvals(2) - zvals(1);
                Nr = numel(rvals);
                Nz = numel(zvals);
            
                % discretize Fokker-Planck operators
                nu_aa1 = n_vals1(spatialIndex)/(Ta_vals1(spatialIndex)^(3/2));
                nu_ae1 = sqrt(2*me)*n_vals1(spatialIndex)/(Te_vals1(spatialIndex)^(3/2));
                C_aa_r1 = nu_aa1*GetFokkerPlanckFlux(Ar, Br, Cr, u_perp(spatialIndex), Ta_vals1(spatialIndex), ma, rvals, tval, dr);
                C_ae_r1 = nu_ae1*GetFokkerPlanckFlux(Ar, Br, Cr, u_perp(spatialIndex), Te_vals1(spatialIndex), ma, rvals, tval, dr);
                C_aa_z1 = nu_aa1*GetFokkerPlanckFlux(Az, Bz, Cz, u_para1(spatialIndex), Ta_vals1(spatialIndex), ma, zvals, tval, dz);
                C_ae_z1 = nu_ae1*GetFokkerPlanckFlux(Az, Bz, Cz, u_para1(spatialIndex), Te_vals1(spatialIndex), ma, zvals, tval, dz);
                Cr1 = C_aa_r1 + C_ae_r1;
                Cz1 = C_aa_z1 + C_ae_z1;
            
                % discretize Lorentz force
                [Dz1, ~] = GetLorentz(dx, x_min, x_max, zvals, ma, qe, qa, n_vals1, Te_vals1, spatialIndex);
            
                % discretize velocity explicitly
                Dx1 = GetVlasov(gamma*dt, dx, Zmat, f_vals_low_rank, leftBC, rightBC, spatialIndex);

                W0 = (Vr0*S0*Vz0') - Dx1;
            
                Vr0_star = Vr0;
                Vz0_star = Vz0;
            
                K1 = sylvester(eye(Nr) - (gamma*dt*Cr1), gamma*dt*((Dz1 - Cz1)*Vz0_star)'*Vz0_star, W0*Vz0_star);
                L1 = sylvester(eye(Nz) + gamma*dt*(Dz1 - Cz1), -gamma*dt*(Cr1*Vr0_star)'*(rvals.*Vr0_star), W0'*(rvals .* Vr0_star));
                
                [Vr1_ddagger, ~] = qr2(K1, rvals);
                [Vz1_ddagger, ~] = qr(L1, 0);
            
                [Vr1_hat, Vz1_hat] = reduced_augmentation([Vr1_ddagger, Vr0], [Vz1_ddagger, Vz0], rvals);
            
                S1_hat = sylvester((eye(size(Vr1_hat, 2)) - (gamma*dt*((rvals .* Vr1_hat)')*(Cr1*Vr1_hat))), gamma*dt*((Dz1 - Cz1)*Vz1_hat)'*Vz1_hat, ((rvals .* Vr1_hat)'*W0*Vz1_hat));
                [Vr1, S1, Vz1, rank] = LoMaC(Vr1_hat, S1_hat, Vz1_hat, Rmat, Zmat, rvals, zvals, tolerance, rhoM1, JzM1, kappaM1, wr, wz, c, w_norm_1_squared, w_norm_v_squared, w_norm_v2_squared);
                
                % f_vals_low_rank_temp{spatialIndex, 1} = Vr1;
                % f_vals_low_rank_temp{spatialIndex, 2} = S1;
                % f_vals_low_rank_temp{spatialIndex, 3} = Vz1;
                f_vals_Vr{spatialIndex} = Vr;
                f_vals_S{spatialIndex} = S;
                f_vals_Vz{spatialIndex} = Vz;
            end

            % reassemble into cell array
            f_vals_low_rank_temp = [f_vals_Vr, f_vals_S, f_vals_Vz];

            %%% STAGE 2 %%%
            [n_vals2, u_para2, Ta_vals2, Te_vals2, u_hat2, nu_hat2, S_hat2, Q_hat2, nTe_hat2, kappaTx2] = fluid_solver_IMEX222_stage2(f_vals_low_rank_temp, n_vals, u_para, Ta_vals, Te_vals, n_vals1, u_para1, Ta_vals1, Te_vals1, nu_hat1, S_hat1, Q_hat1, nTe_hat1, dt, dx, dr, dz, Rmat, Zmat, qa, qe, ma, me, R_const, x_min, x_max);
            nu2 = n_vals2 .* u_para2;
            nU2 = 0.5*((3/ma)*n_vals2.*Ta_vals2 + n_vals2.*u_para2.^2);

            % if abs(tval - 1e-5) < dt || abs(tval - tf) < dt
            %     figure; clf;
            %     plot(xvals, n_vals, "LineWidth", 1.5); hold on;
            %     plot(xvals, u_para./u_para(1), "LineWidth",1.5);
            %     plot(xvals, Te_vals, "LineWidth", 1.5);
            %     plot(xvals, Ta_vals, "LineWidth", 1.5);
            %     legend('n', 'u_{||}', 'T_e', 'T_a');
            %     title(sprintf('Mass, momentum, ion temperature, and electron temperature at t=%s', num2str(tval)));
            %     ylim([0, 1.2]);
            %     saveas(gcf, sprintf('Moments-Plots/moments_time_%s.m', num2str(round(tval))));
            %     pause(0.05);
            % end

            f_vals_low_rank_temp2 = cell(Nx, 3);
            f_vals_Vr = cell(Nx, 1);
            f_vals_S = cell(Nx, 1);
            f_vals_Vz = cell(Nx, 1);
        
            parfor spatialIndex = 1:Nx
                Vr0 = f_vals_low_rank{spatialIndex, 1};
                S0 = f_vals_low_rank{spatialIndex, 2};
                Vz0 = f_vals_low_rank{spatialIndex, 3};
                Vr1 = f_vals_low_rank_temp{spatialIndex, 1};
                S1 = f_vals_low_rank_temp{spatialIndex, 2};
                Vz1 = f_vals_low_rank_temp{spatialIndex, 3};

                rhoM2 = n_vals2(spatialIndex);
                JzM2  = nu2(spatialIndex);
                kappaM2 = nU2(spatialIndex);

                % discretize Fokker-Planck operators
                nu_aa1 = n_vals1(spatialIndex)/(Ta_vals1(spatialIndex)^(3/2));
                nu_ae1 = sqrt(2*me)*n_vals1(spatialIndex)/(Te_vals1(spatialIndex)^(3/2));
                C_aa_r1 = nu_aa1*GetFokkerPlanckFlux(Ar, Br, Cr, u_perp(spatialIndex), Ta_vals1(spatialIndex), ma, rvals, tval, dr);
                C_ae_r1 = nu_ae1*GetFokkerPlanckFlux(Ar, Br, Cr, u_perp(spatialIndex), Te_vals1(spatialIndex), ma, rvals, tval, dr);
                C_aa_z1 = nu_aa1*GetFokkerPlanckFlux(Az, Bz, Cz, u_para1(spatialIndex), Ta_vals1(spatialIndex), ma, zvals, tval, dz);
                C_ae_z1 = nu_ae1*GetFokkerPlanckFlux(Az, Bz, Cz, u_para1(spatialIndex), Te_vals1(spatialIndex), ma, zvals, tval, dz);
                Cr1 = C_aa_r1 + C_ae_r1;
                Cz1 = C_aa_z1 + C_ae_z1;

                nu_aa2 = n_vals2(spatialIndex)/(Ta_vals2(spatialIndex)^(3/2));
                nu_ae2 = sqrt(2*me)*n_vals2(spatialIndex)/(Te_vals2(spatialIndex)^(3/2));
                C_aa_r2 = nu_aa2*GetFokkerPlanckFlux(Ar, Br, Cr, u_perp(spatialIndex), Ta_vals2(spatialIndex), ma, rvals, tval+dt, dr);
                C_ae_r2 = nu_ae2*GetFokkerPlanckFlux(Ar, Br, Cr, u_perp(spatialIndex), Te_vals2(spatialIndex), ma, rvals, tval+dt, dr);
                C_aa_z2 = nu_aa2*GetFokkerPlanckFlux(Az, Bz, Cz, u_para2(spatialIndex), Ta_vals2(spatialIndex), ma, zvals, tval+dt, dz);
                C_ae_z2 = nu_ae2*GetFokkerPlanckFlux(Az, Bz, Cz, u_para2(spatialIndex), Te_vals2(spatialIndex), ma, zvals, tval+dt, dz);
                Cr2 = C_aa_r2 + C_ae_r2;
                Cz2 = C_aa_z2 + C_ae_z2;
            
                % discretize Lorentz force
                [Dz1, ~] = GetLorentz(dx, x_min, x_max, zvals, ma, qe, qa, n_vals1, Te_vals1, spatialIndex);
                [Dz2, E] = GetLorentz(dx, x_min, x_max, zvals, ma, qe, qa, n_vals2, Te_vals2, spatialIndex);
                spatial_Efield(spatialIndex) = E;
            
                % discretize velocity explicitly
                Dx1 = GetVlasov(delta*dt, dx, Zmat, f_vals_low_rank, leftBC, rightBC, spatialIndex);
                Dx2 = GetVlasov((1-delta)*dt, dx, Zmat, f_vals_low_rank_temp, leftBC, rightBC, spatialIndex);

                Y1 = (Cr1*Vr1)*S1*(Vz1') + (Vr1)*S1*(((Cz1 - Dz1)*Vz1)');
                W1 = (Vr0*S0*(Vz0')) - Dx1 - Dx2 + (1-gamma)*dt*Y1;

                % Reduced Augmentation
                % Predict V_dagger using B. Euler for second stage
                [Vr1_dagger, ~, Vz1_dagger, ~] = IMEX111(Vr0, S0, Vz0, u_perp, u_para2, dt, dx, tval, rvals, zvals, x_min, x_max, f_vals_low_rank, Rmat, Zmat, ma, me, qa, qe, Ar, Az, Br, Bz, Cr, Cz, tolerance, n_vals2, Ta_vals2, Te_vals2, rhoM2, JzM2, kappaM2, spatialIndex, R_const, leftBC, rightBC, wr, wz, c, w_norm_1_squared, w_norm_v_squared, w_norm_v2_squared);
                [Vr1_star, Vz1_star] = reduced_augmentation([Vr1_dagger, Vr1, Vr0], [Vz1_dagger, Vz1, Vz0], rvals);
               
                % K/L-Step
                K2 = sylvester(eye(Nr) - (gamma*dt*Cr2), gamma*dt*((Dz2 - Cz2)*Vz1_star)'*Vz1_star, W1*Vz1_star);
                L2 = sylvester(eye(Nz) + gamma*dt*(Dz2 - Cz2), -gamma*dt*(Cr2*Vr1_star)'*(rvals.*Vr1_star), W1'*(rvals .* Vr1_star));
            
                % Get bases
                [Vr2_ddagger, ~] = qr2(K2, rvals); [Vz2_ddagger, ~] = qr(L2, 0);
            
                % Reduced Augmentation
                [Vr2_hat, Vz2_hat] = reduced_augmentation([Vr2_ddagger, Vr1, Vr0], [Vz2_ddagger, Vz1, Vz0], rvals);
            
                % S-Step
                S2_hat = sylvester((eye(size(Vr2_hat, 2)) - (gamma*dt*((rvals .* Vr2_hat)')*(Cr2*Vr2_hat))), gamma*dt*((Dz2 - Cz2)*Vz2_hat)'*Vz2_hat, ((rvals .* Vr2_hat)'*W1*Vz2_hat));
                [Vr2, S2, Vz2, rank] = LoMaC(Vr2_hat, S2_hat, Vz2_hat, Rmat, Zmat, rvals, zvals, tolerance, rhoM2, JzM2, kappaM2, wr, wz, c, w_norm_1_squared, w_norm_v_squared, w_norm_v2_squared);

                % f_vals_low_rank_temp2{spatialIndex, 1} = Vr2;
                % f_vals_low_rank_temp2{spatialIndex, 2} = S2;
                % f_vals_low_rank_temp2{spatialIndex, 3} = Vz2;  
                f_vals_Vr{spatialIndex} = Vr;
                f_vals_S{spatialIndex} = S;
                f_vals_Vz{spatialIndex} = Vz;

                % use moments from actual soln rather than from pesky fluid
                % solver
                f = Vr2*S2*Vz2';
                spatial_rank_vals(spatialIndex, 1) = rank;
                spatial_min_vals(spatialIndex, 1) = min(min(f));
                n_vals_diff(spatialIndex) = 2*pi*dr*dz*sum(sum(f .* Rmat));
                u_vals_diff(spatialIndex) = 2*pi*dr*dz*sum(sum(Zmat .* f .* Rmat))./n_vals_diff(spatialIndex);
                Ta_vals_diff(spatialIndex) = (2*pi*dr*dz*sum(sum((Rmat.^2 + Zmat.^2).*f.*Rmat)) - n_vals_diff(spatialIndex)*u_vals_diff(spatialIndex)^2)/(3*n_vals_diff(spatialIndex)/ma);
            end

            % reassemble into cell array
            f_vals_low_rank_temp2 = [f_vals_Vr, f_vals_S, f_vals_Vz];

            f_vals_low_rank_temp = f_vals_low_rank_temp2;

            n_vals = n_vals2;
            u_para = u_para2;
            Ta_vals = Ta_vals2;
            Te_vals = Te_vals2; 

            % update mass, momentum, energy (IMEX222)
            flux_diff_n = flux_diff_n...
                + dt*(delta)*(nu_hat1(end) - nu_hat1(1))...
                + dt*(1-delta)*(nu_hat2(end) - nu_hat2(1));
            flux_diff_nu = flux_diff_nu...
                + dt*(delta)*((S_hat1(end) - S_hat1(1)))...
                - dt*(1-gamma)*(qa/(2*qe*ma))*(n_IC(x_max + dx/2)*Te_IC(x_max + dx/2) + n_vals1(end)*Te_vals1(end) - n_vals1(1)*Te_vals1(1) - n_IC(x_min - dx/2)*Te_IC(x_min - dx/2))...
                + dt*(1-delta)*((S_hat2(end) - S_hat2(1)))...
                - dt*(gamma)*(qa/(2*qe*ma))*(n_IC(x_max + dx/2)*Te_IC(x_max + dx/2) + n_vals2(end)*Te_vals(end) - n_vals2(1)*Te_vals2(1) - n_IC(x_min - dx/2)*Te_IC(x_min - dx/2));
            flux_diff_nU = flux_diff_nU ...
                + dt*(delta)*(Q_hat1(end) - Q_hat1(1))...
                + dt*(delta)*2.5*(u_hat1(end)*nTe_hat1(end) - u_hat1(1)*nTe_hat1(1))...
                - dt*(1-gamma)*(kappaTx1(end) - kappaTx1(1))...
                + dt*(1-delta)*(Q_hat2(end) - Q_hat2(1))...
                + dt*(1-delta)*2.5*(u_hat2(end)*nTe_hat2(end) - u_hat2(1)*nTe_hat2(1))...
                - dt*(gamma)*(kappaTx2(end) - kappaTx2(1));

    end

    % update f_vals simultaneously
    f_vals_low_rank = f_vals_low_rank_temp;
    avg_ranks(t_index, 1) = mean(spatial_rank_vals);
    min_vals(t_index, 1) = min(spatial_min_vals);
    Efield(t_index, 1) = sqrt(dx*sum(abs(spatial_Efield) .^ 2));
                                
    mass(t_index) = dx*ma*sum(n_vals_diff) + flux_diff_n;
    momentum(t_index) = dx*ma*sum(n_vals_diff .* u_vals_diff) + flux_diff_nu;
    energy(t_index) = dx*ma*sum(0.5*((3/ma)*n_vals_diff.*Ta_vals_diff + n_vals_diff.*u_vals_diff.^2) + (3/2)*n_vals_diff.*Te_vals) + flux_diff_nU;

    n_vals = n_vals_diff;
    u_para = u_vals_diff;
    Ta_vals = Ta_vals_diff;
end

end





% figure(1); clf;
% plot(xvals, n_vals, "LineWidth", 1.5); hold on;
% plot(xvals, u_para./u_para(1), "LineWidth",1.5);
% plot(xvals, Te_vals, "LineWidth", 1.5);
% plot(xvals, Ta_vals, "LineWidth", 1.5);
% legend('n', 'nu_{||}', 'T_e', 'T_a');
% title(sprintf('Mass, momentum, ion temperature, and electron temperature at t=%s', num2str(tval)));
% ylim([0, 1.2]);
% pause(0.05);
% 
% figure(4); clf; plot(tvals, abs(mass-mass(1))/mass(1), 'k-', 'LineWidth', 1.5);
% xlabel('t'); ylabel('Relative error (mass)'); title('Relative mass of numerical solution over time');
% 
% figure(5); clf; plot(tvals, abs(momentum-momentum(1)), 'k-', 'LineWidth', 1.5);
% xlabel('t'); ylabel('Absolute error (Uz)'); title('Absolute error of bulk velocity over time');
% 
% figure(6); clf; plot(tvals, abs(energy-energy(1))/energy(1), 'k-', 'LineWidth', 1.5);
% xlabel('t'); ylabel('Relative error (Energy)'); title('Relative energy of numerical solution over time');

% Electric field
figure; clf;
semilogy(tvals, Efield, 'LineWidth', 1.5);
xlabel('t'); ylabel('E_2'); title('L_2 norm of Electric Field over Time');

PlotF(f_vals_low_rank, Xmat, Rmat, Zmat2, Nz, 10);
title(sprintf('Numerical solution at time t=%s', num2str(tf)));

return
%%
% Mass
figure(4); clf; hold on;

plot(tvals, abs(mass-mass(1))/mass(1), 'b-', 'LineWidth', 1.5);
xlabel('t'); 

plot(tvals, abs(momentum-momentum(1))/momentum(1), 'k-', 'LineWidth', 1.5);
xlabel('t'); 

plot(tvals, abs(energy-energy(1))/energy(1), 'g-', 'LineWidth', 1.5);
xlabel('t');

legend('Mass deviation', 'Momentum deviation', 'Energy deviation');
title('Mass, momentum, and energy conservation');
ylabel('Deviation');

% Rank plot
figure(7); clf;
plot(tvals, avg_ranks_total(:, 1), 'black-', 'LineWidth', 1.5); hold on;
plot(tvals, avg_ranks_total(:, 2), 'blue-', 'LineWidth', 1.5);
% plot(ranks3(:, 1), ranks3(:, 2), 'green-', 'LineWidth', 1.5);
xlabel('time'); ylabel('rank'); title('Average rank plot');
legend('Backward Euler', 'IMEX222');

% Electric field
figure; clf;
semilogy(tvals, Efield, 'LineWidth', 1.5);
xlabel('t'); ylabel('E_2'); title('L_2 norm of Electric Field over Time');

% Moments
figure(3); clf;
plot(xvals, n_vals, "LineWidth", 1.5); hold on;
plot(xvals, u_para./u_para(1), "LineWidth",1.5);
plot(xvals, Te_vals, "LineWidth", 1.5);
plot(xvals, Ta_vals, "LineWidth", 1.5);
legend('n', 'u_{||}', 'T_e', 'T_a');
title(sprintf('Mass, momentum, ion temperature, and electron temperature at t=%s', num2str(tval)));
ylim([0, 1.2]);
% saveas(gcf, sprintf('Moments-Plots/moments_time_%s.m', num2str(round(tval))));




%%%%%% FUNCTIONS %%%%%%
function [Dx] = GetVlasov(dt, dx, Zmat, f_vals_low_rank, leftBC, rightBC, i)
    f_i = f_vals_low_rank{i, 1}*f_vals_low_rank{i, 2}*f_vals_low_rank{i, 3}';
    if i == 1
        f_i_pos = f_vals_low_rank{i+1, 1}*f_vals_low_rank{i+1, 2}*f_vals_low_rank{i+1, 3}';
        f_i_neg = leftBC;
    elseif i == size(f_vals_low_rank, 1)
        f_i_pos = rightBC;
        f_i_neg = f_vals_low_rank{i-1, 1}*f_vals_low_rank{i-1, 2}*f_vals_low_rank{i-1, 3}';
    else
        f_i_pos = f_vals_low_rank{i+1, 1}*f_vals_low_rank{i+1, 2}*f_vals_low_rank{i+1, 3}';
        f_i_neg = f_vals_low_rank{i-1, 1}*f_vals_low_rank{i-1, 2}*f_vals_low_rank{i-1, 3}';
    end
    Dx = (dt/dx)*max(Zmat, 0).*(f_i - f_i_neg) + (dt/dx)*min(Zmat, 0).*(f_i_pos - f_i);
end

function [Lorentz, E] = GetLorentz(dx, x_min, x_max, zvals, ma, qe, qa, ne_vals, Te_vals, i)
    Nx = numel(ne_vals);
    Nz = numel(zvals);
    dz = zvals(2) - zvals(1);

    % first compute E_para using Generalized Ohm's Law
    [n0, ~, Te0] = get_boundaries(x_min, x_max);
    n_leftBC = n0(x_min - dx/2);
    n_rightBC = n0(x_max + dx/2);
    Te_leftBC = Te0(x_min - dx/2);
    Te_rightBC = Te0(x_max + dx/2);
    if i == 1
        E = (1/(2*dx*ne_vals(i)*qe))*(ne_vals(i+1)*Te_vals(i+1) - n_leftBC*Te_leftBC); % centered difference
    elseif i == Nx
        E = (1/(2*dx*ne_vals(i)*qe))*(n_rightBC*Te_rightBC - ne_vals(i-1)*Te_vals(i-1)); % centered difference
    else
        E = (1/(2*dx*ne_vals(i)*qe))*(ne_vals(i+1)*Te_vals(i+1) - ne_vals(i-1)*Te_vals(i-1)); % centered difference
    end

    diff_mtx_pos = (1/dz)*(spdiags(ones(Nz, 1), 0, Nz, Nz) + spdiags(-1*ones(Nz, 1), -1, Nz, Nz));
    diff_mtx_neg = -1*diff_mtx_pos';
    Lorentz = max(E, 0)*(qa/ma)*diff_mtx_pos + min(E, 0)*(qa/ma)*diff_mtx_neg; 
end

function [Flux] = GetFokkerPlanckFlux(A, B, C, u, T, m, xvals, t, dx)

    % using Pareschi scheme
    N = numel(xvals);
    A = A(u, xvals, t);
    B = B(u, xvals(1:N-1) + dx/2, t);
    C = C(u, xvals(1:N-1) + dx/2, t, T, m);
    
    w = dx*B./(C + 1e-14); % prevent zero division
    delta = (1 ./ w) - (1 ./ (exp(w) - 1));

    F1 = -((1/dx)*C - delta.*B);
    F2 = (1 - delta).*B + (1/dx)*C;

    F_pos = spdiags([F1;0], 0, N, N) + spdiags([0;F2], 1, N, N);
    F_neg = spdiags([0; F2], 0, N, N) + spdiags(F1, -1, N, N);

    Flux = diag(1./A)*(1/dx)*(F_pos - F_neg);
end

function [Vr, S, Vz, rank] = IMEX111(Vr0, S0, Vz0, ur, uz, dt, dx, tval, rvals, zvals, x_min, x_max, f_vals_low_rank, Rmat, Zmat, ma, me, qa, qe, Ar, Az, Br, Bz, Cr, Cz, tolerance, n_vals, Ta_vals, Te_vals, rhoM, JzM, kappaM, spatialIndex, R_const, leftBC, rightBC, wr, wz, c, w_norm_1_squared, w_norm_v_squared, w_norm_v2_squared)
    dr = rvals(2) - rvals(1);
    dz = zvals(2) - zvals(1);
    Nr = numel(rvals);
    Nz = numel(zvals);

    % discretize Fokker-Planck operators
    nu_aa = n_vals(spatialIndex)/(Ta_vals(spatialIndex)^(3/2));
    nu_ae = sqrt(2*me)*n_vals(spatialIndex)/(Te_vals(spatialIndex)^(3/2));
    C_aa_r1 = nu_aa*GetFokkerPlanckFlux(Ar, Br, Cr, ur(spatialIndex), Ta_vals(spatialIndex), ma, rvals, tval, dr);
    C_ae_r1 = nu_ae*GetFokkerPlanckFlux(Ar, Br, Cr, ur(spatialIndex), Te_vals(spatialIndex), ma, rvals, tval, dr);
    C_aa_z1 = nu_aa*GetFokkerPlanckFlux(Az, Bz, Cz, uz(spatialIndex), Ta_vals(spatialIndex), ma, zvals, tval, dz);
    C_ae_z1 = nu_ae*GetFokkerPlanckFlux(Az, Bz, Cz, uz(spatialIndex), Te_vals(spatialIndex), ma, zvals, tval, dz);
    Cr1 = C_aa_r1 + C_ae_r1;
    Cz1 = C_aa_z1 + C_ae_z1;

    % discretize Lorentz force
    [Dz1, ~] = GetLorentz(dx, x_min, x_max, zvals, ma, qe, qa, n_vals, Te_vals, spatialIndex);

    % discretize velocity explicitly
    Dx1 = GetVlasov(dt, dx, Zmat, f_vals_low_rank, leftBC, rightBC, spatialIndex);
    W0 = (Vr0*S0*Vz0') - Dx1;

    Vr0_star = Vr0;
    Vz0_star = Vz0;

    K1 = sylvester(eye(Nr) - (dt*Cr1), dt*((Dz1 - Cz1)*Vz0_star)'*Vz0_star, W0*Vz0_star);
    L1 = sylvester(eye(Nz) + dt*(Dz1 - Cz1), -dt*(Cr1*Vr0_star)'*(rvals.*Vr0_star), W0'*(rvals .* Vr0_star));
    
    [Vr1_ddagger, ~] = qr2(K1, rvals);
    [Vz1_ddagger, ~] = qr(L1, 0);

    [Vr1_hat, Vz1_hat] = reduced_augmentation([Vr1_ddagger, Vr0], [Vz1_ddagger, Vz0], rvals);

    S1_hat = sylvester((eye(size(Vr1_hat, 2)) - (dt*((rvals .* Vr1_hat)')*(Cr1*Vr1_hat))), dt*((Dz1 - Cz1)*Vz1_hat)'*Vz1_hat, ((rvals .* Vr1_hat)'*W0*Vz1_hat));
    [Vr, S, Vz, rank] = LoMaC(Vr1_hat, S1_hat, Vz1_hat, Rmat, Zmat, rvals, zvals, tolerance, rhoM, JzM, kappaM, wr, wz, c, w_norm_1_squared, w_norm_v_squared, w_norm_v2_squared);
end

function [Vr, Vz] = reduced_augmentation(Vr_aug, Vz_aug, rvals)
    tolerance = 1e-14;
    [Qr, Rr] = qr2(Vr_aug, rvals);
    [Qz, Rz] = qr(Vz_aug, 0);
    [Ur, Sr, ~] = svd(Rr, 0);
    [Uz, Sz, ~] = svd(Rz, 0);
    rr = find(diag(Sr) > tolerance, 1, 'last');
    rz = find(diag(Sz) > tolerance, 1, 'last');
    rank = max(rr, rz);
    rank = min(rank, min(size(Ur, 2), size(Uz, 2)));
    Vr = Qr*Ur(:, 1:rank);
    Vz = Qz*Uz(:, 1:rank);
end

function [Q, R] = qr2(X, rvals)
    [Q, R] = qr(sqrt(rvals) .* X, 0);
    Q = Q ./ sqrt(rvals);
end

function [U, S, V] = svd2(X, rvals)
    [U, S, V] = svd(sqrt(rvals) .* X, 0);
    U = U./sqrt(rvals);
end

function [X, R, Z, dx, dr, dz] = GetRZ(Nx, Nr, Nz, interval)
    xvals = linspace(interval(1), interval(2), Nx+1)';
    rvals = linspace(interval(3), interval(4), Nr+1)';
    zvals = linspace(interval(5), interval(6), Nz+1)';
    dx = xvals(2) - xvals(1);
    dr = rvals(2) - rvals(1);
    dz = zvals(2) - zvals(1);
    xmid = xvals(1:end-1) + dx/2; % centered mesh
    rmid = rvals(1:end-1) + dr/2; % centered mesh
    zmid = zvals(1:end-1) + dz/2; % centered mesh
    [R, Z] = meshgrid(rmid, zmid); 
    X = xmid; R = R'; Z = Z';
end



% ------- FLUID SOLVER STUFF ------- %
function [n1, u_para1, T_a1, T_e1, u_para0_half_nodes, nu_hat1, S_hat1, Q_hat1, nTe_hat1, kappaTx] = fluid_solver_IMEX111(f_vals_low_rank, n0, u_para0, T_a0, T_e0, dt, dx, dv_perp, dv_para, v_perp, v_para, qa, qe, ma, me, R_const, x_min, x_max)
    Nx = numel(n0); % max val of i, j
    x_ghost_left = x_min - dx/2; % left ghost cell
    x_ghost_right = x_max + dx/2; % right ghost cell

    % get boundary conditions
    [n0_boundary, u_para0_boundary, T_ae_boundary] = get_boundaries(x_min, x_max); % Ta = Te at boundary --> T_ae
    n_BC_left = n0_boundary(x_ghost_left); n_BC_right = n0_boundary(x_ghost_right);
    u_para_BC_left = u_para0_boundary(x_ghost_left); u_para_BC_right = u_para0_boundary(x_ghost_right);
    Tae_BC_left = T_ae_boundary(x_ghost_left); Tae_BC_right = T_ae_boundary(x_ghost_right);

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%% ---------- STAGE ONE ----------- %%%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    n0_pos = [n0; n_BC_right]; n0_neg = [n_BC_left; n0];
    u_para0_half_nodes = ([u_para_BC_left; u_para0] + [u_para0; u_para_BC_right])/2; %u_para0_half_nodes = [u_para0_min; u_para0_half_nodes; u_para0_max];
    U0 = 0.5*((3/ma)*T_a0 + u_para0.^2);
    Te0_pos = [T_e0(2:end); Tae_BC_right]; Te0_neg = [Tae_BC_left; T_e0(1:end-1)];

    % first, compute fluxes via summation
    [nu_hat1, S_hat1, Q_hat1] = get_fluxes(f_vals_low_rank, v_perp, v_para, R_const, x_min, x_max, dx, dv_perp, dv_para);
    nTe_hat1 = ((n0_neg.*[Tae_BC_left; T_e0]).*(u_para0_half_nodes > 0) + (n0_pos.*[T_e0; Tae_BC_right]).*(u_para0_half_nodes <= 0)); % upwinding

    % shift bounds to get flux pos/neg
    nu_hat1_pos = nu_hat1(2:end); nu_hat1_neg = nu_hat1(1:end-1);

    S_hat1_pos = S_hat1(2:end); S_hat1_neg = S_hat1(1:end-1);
    Q_hat1_pos = Q_hat1(2:end); Q_hat1_neg = Q_hat1(1:end-1);
    nTe_hat1_pos = nTe_hat1(2:end); nTe_hat1_neg = nTe_hat1(1:end-1);
  
    % explicitly find n via Forward Euler
    n1 = n0 - (dt/dx)*(nu_hat1_pos - nu_hat1_neg); % now find n_i+1, n_i-1
    n_pos = [n1(2:end); n_BC_right]; n_neg = [n_BC_left; n1(1:end-1)];

    % ---- init y_vec, R_norm ----  
    % y = [n0.*u_para0; n0.*U0; T_e0];
    y = [n1.*u_para0; n1.*U0; T_e0];

    nu = y(1:Nx); 
    nU = y(Nx+1:2*Nx); 
    T_e = y(2*Nx+1:end);
    Te_pos = [T_e(2:end); Tae_BC_right]; Te_neg = [Tae_BC_left; T_e(1:end-1)];
    nTe_pos = n_pos.*Te_pos; nTe_neg = n_neg.*Te_neg;

    kappa_pos = (3.2/(2*sqrt(2*me)))*((Te_pos.^(5/2) + T_e.^(5/2)));
    kappa_neg = (3.2/(2*sqrt(2*me)))*((T_e.^(5/2) + Te_neg.^(5/2))); 

    R1 = nu - (n0.*u_para0) + (dt/dx).*(S_hat1_pos - S_hat1_neg) - ((dt*qa)/(2*dx*qe*ma)).*((n_pos.*Te_pos) - (n_neg.*Te_neg));
    R2 = nU - (n0.*U0) + (dt/dx).*(Q_hat1_pos - Q_hat1_neg) - (((dt*qa*nu)./(2*dx*qe*n1)).*((n_pos.*Te_pos) - (n_neg.*Te_neg))) - (((dt.*3.*sqrt(2*me))./((ma.^2).*(T_e.^(3/2)))) .* (((n1.^2).*T_e) - ((ma/3).*((2.*n1.*nU) - (nu.^2)))));
    R3 = (n1.*T_e) - (n0.*T_e0) + ((5*dt)/(3*dx)).*((u_para0_half_nodes(2:end).*nTe_hat1_pos) - (u_para0_half_nodes(1:end-1).*nTe_hat1_neg)) - (((dt*(nu./n1))./(3*dx)).*(nTe_pos - nTe_neg)) - (((2*dt)/(3*dx.^2)) .* ((kappa_pos.*(Te_pos - T_e)) - (kappa_neg.*(T_e - Te_neg)))) - (((dt.*2.*sqrt(2*me))./(ma.*(T_e.^(3/2)))) .* (((ma/3).*((2*n1.*nU) - (nu.^2))) - ((n1.^2).*T_e)));
    R = [R1; R2; R3];

    tol = min(5e-12, max(abs(R))*5e-10); % ensure we don't get worse!
   
    while max(abs(R)) > tol
        % define partial derivatives of residual
        nu_nu = spdiags(ones(Nx), 0, Nx, Nx);
        nu_nU = spdiags(zeros(Nx),0, Nx, Nx);
        nu_Te = gallery('tridiag', (dt*qa*n1(1:end-1))/(2*dx*qe*ma), zeros(Nx,1), -(dt*qa*n1(2:end))/(2*dx*qe*ma));
    
        nU_nu = diag( ((-dt*qa)./(2*dx.*qe.*n1)).*((n_pos.*Te_pos) - (n_neg.*Te_neg)) );
        nU_nU = spdiags(ones(Nx), 0, Nx, Nx);
        nU_Te_mid = ((3*dt*sqrt(2*me))./(2*(ma.^2))).*(((n1.^2)./(T_e.^(3/2))  + (ma./(T_e.^(5/2))).*((2*n1.*nU) - (nu.^2)) ));
        nU_Te = gallery('tridiag', (dt.*qa.*nu(2:end).*(n1(1:end-1)./n1(2:end)))./(2*dx*qe), nU_Te_mid, -(dt.*qa.*nu(1:end-1).*(n1(2:end)./n1(1:end-1)))/(2*dx*qe) );
    
        Te_nu = diag(-(dt.*((n_pos.*Te_pos) - (n_neg.*Te_neg)))./(3*dx*n1));
        Te_nU = spdiags(zeros(Nx), 0, Nx, Nx);
        Te_Te_left = ((dt.*nu.*n_neg)./(3*dx.*n1)) + (((dt*3.2)./(3*(dx.^2).*sqrt(2*me))).*(((5.*(Te_neg.^(3/2))/2).*(T_e - Te_neg)) - (T_e.^(5/2) + Te_neg.^(5/2)))); Te_Te_left = Te_Te_left(2:end);
        Te_Te_mid = n1 - (((dt*3.2)./(3*(dx.^2).*sqrt(2*me))).*(((5.*(T_e.^(3/2))./2).*(Te_pos - T_e)) - (Te_pos.^(5/2) + T_e.^(5/2)) - ((5.*(T_e.^(3/2))/2).*(T_e - Te_neg)) - (T_e.^(5/2) + Te_neg.^(5/2)))) - ((2*dt*sqrt(2*me)./(2*ma)).*(((-ma./(T_e.^(5/2))).*(2*n1.*nU - (nu.^2)) + ((n1.^2)./(T_e.^(3/2))))));
        Te_Te_right = ((-dt.*nu.*n_pos)./(3*dx.*n1)) - (((dt*3.2)./(3*(dx.^2).*sqrt(2*me))).*(((5.*(Te_pos.^(3/2))/2).*(Te_pos - T_e)) + (Te_pos.^(5/2) + T_e.^(5/2)))); Te_Te_right = Te_Te_right(1:end-1);
        Te_Te = gallery('tridiag', Te_Te_left, Te_Te_mid, Te_Te_right);

        P = [nu_nu, nu_nU, nu_Te;
             nU_nu, nU_nU, nU_Te;
             Te_nu, Te_nU, Te_Te]; % holy block matrix
     
        dy = -P\R; % solve for delta y at time l+1
        y = y + dy;

        % update y_vec stuff
        nu = y(1:Nx); 
        nU = y(Nx+1:2*Nx); 
        T_e = y(2*Nx+1:end);
        Te_pos = [T_e(2:end); Tae_BC_right]; Te_neg = [Tae_BC_left; T_e(1:end-1)];
        nTe_pos = n_pos.*Te_pos; nTe_neg = n_neg.*Te_neg;

        kappa_pos = (3.2/(2*sqrt(2*me)))*((Te_pos.^(5/2) + T_e.^(5/2)));
        kappa_neg = (3.2/(2*sqrt(2*me)))*((T_e.^(5/2) + Te_neg.^(5/2)));
        
        R1 = nu - (n0.*u_para0) + (dt/dx).*(S_hat1_pos - S_hat1_neg) - ((dt*qa)/(2*dx*qe*ma)).*((n_pos.*Te_pos) - (n_neg.*Te_neg));
        R2 = nU - (n0.*U0) + (dt/dx).*(Q_hat1_pos - Q_hat1_neg) - (((dt*qa*nu)./(2*dx*qe*n1)).*((n_pos.*Te_pos) - (n_neg.*Te_neg))) - (((dt.*3.*sqrt(2*me))./((ma.^2).*(T_e.^(3/2)))) .* (((n1.^2).*T_e) - ((ma/3).*((2.*n1.*nU) - (nu.^2)))));
        R3 = (n1.*T_e) - (n0.*T_e0) + ((5*dt)/(3*dx)).*((u_para0_half_nodes(2:end).*nTe_hat1_pos) - (u_para0_half_nodes(1:end-1).*nTe_hat1_neg)) - (((dt*(nu./n1))./(3*dx)).*(nTe_pos - nTe_neg)) - (((2*dt)/(3*dx.^2)) .* ((kappa_pos.*(Te_pos - T_e)) - (kappa_neg.*(T_e - Te_neg)))) - (((dt.*2.*sqrt(2*me))./(ma.*(T_e.^(3/2)))) .* (((ma/3).*((2*n1.*nU) - (nu.^2))) - ((n1.^2).*T_e)));
        R = [R1; R2; R3];
    end
  
    % parameters to return
    nu1 = (y(1:Nx));
    nU1 = y(Nx+1:2*Nx);
    T_e1 = y(2*Nx+1:end);

    u_para1 = nu1 ./ n1;
    T_a1 = (ma/3)*(2*nU1./n1 - (nu1.^2)./(n1.^2));

    Te_all = [Tae_BC_left; T_e1; Tae_BC_right];
    kappaTx = (3.2/(2*sqrt(2*me)*dx))*(Te_all(1:end-1).^(2.5)+Te_all(2:end).^(2.5)).*(Te_all(2:end)-Te_all(1:end-1));
end

function [n2, u_para2, T_a2, T_e2, u_para1_half_nodes, nu_hat2, S_hat2, Q_hat2, nTe_hat2, kappaTx2] = fluid_solver_IMEX222_stage2(f1_vals_low_rank, n0, u_para0, T_a0, T_e0, n1, u_para1, T_a1, T_e1, nu_hat1, S_hat1, Q_hat1, nTe_hat1, dt, dx, dv_perp, dv_para, v_perp, v_para, qa, qe, ma, me, R_const, x_min, x_max)
    
    gamma = 1 - (sqrt(2)/2);
    delta = 1 - (1/(2*gamma));
    dt1 = gamma*dt;
    dt2 = (1-gamma)*dt;

    Nx = numel(n0); % max val of i, j
    x_ghost_left = x_min - dx/2; % left ghost cell
    x_ghost_right = x_max + dx/2; % right ghost cell

    % get boundary conditions
    [n0_boundary, u_para0_boundary, T_ae_boundary] = get_boundaries(x_min, x_max); % Ta = Te at boundary --> T_ae
    n_BC_left = n0_boundary(x_ghost_left); n_BC_right = n0_boundary(x_ghost_right);
    u_para_BC_left = u_para0_boundary(x_ghost_left); u_para_BC_right = u_para0_boundary(x_ghost_right);
    u_para0_half_nodes = ([u_para_BC_left; u_para0] + [u_para0; u_para_BC_right])/2;
    Tae_BC_left = T_ae_boundary(x_ghost_left); Tae_BC_right = T_ae_boundary(x_ghost_right);
    U0 = 0.5*((3/ma)*T_a0 + u_para0.^2);

    %%% SAVE STUFF FROM STAGE 1 %%%
    % shift bounds to get flux pos/neg
    nu_hat1_pos = nu_hat1(2:end); nu_hat1_neg = nu_hat1(1:end-1);
    S_hat1_pos = S_hat1(2:end); S_hat1_neg = S_hat1(1:end-1);
    Q_hat1_pos = Q_hat1(2:end); Q_hat1_neg = Q_hat1(1:end-1);
    nTe_hat1_pos = nTe_hat1(2:end); nTe_hat1_neg = nTe_hat1(1:end-1);

    % define A0 vals for later
    An_0 = - (1/dx)*(nu_hat1_pos - nu_hat1_neg);
    Anu_0 = - (1/dx)*(S_hat1_pos - S_hat1_neg);
    AnU_0 = - (1/dx).*(Q_hat1_pos - Q_hat1_neg);
    AnTe_0 = - ((5)/(3*dx)).*((u_para0_half_nodes(2:end).*nTe_hat1_pos) - (u_para0_half_nodes(1:end-1).*nTe_hat1_neg));

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%% ---------- STAGE TWO ----------- %%%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    nu1 = n1.*u_para1;
    nU1 = 0.5*((3/ma)*n1.*T_a1 + n1.*u_para1.^2);

    n1_pos = [n1(2:end); n_BC_right]; n1_neg = [n_BC_left; n1(1:end-1)];
    u_para1_half_nodes = ([u_para_BC_left; u_para1] + [u_para1; u_para_BC_right])/2;
    Te1_pos = [T_e1(2:end); Tae_BC_right]; Te1_neg = [Tae_BC_left; T_e1(1:end-1)];
    nTe1_pos = n1_pos.*Te1_pos; nTe1_neg = n1_neg.*Te1_neg;

    kappa1_pos = (3.2/(2*sqrt(2*me)))*((Te1_pos.^(5/2) + T_e1.^(5/2)));
    kappa1_neg = (3.2/(2*sqrt(2*me)))*((T_e1.^(5/2) + Te1_neg.^(5/2)));

    % recompute fluxes using solution from first time-step
    [nu_hat2, S_hat2, Q_hat2] = get_fluxes(f1_vals_low_rank, v_perp, v_para, R_const, x_min, x_max, dx, dv_perp, dv_para);
    nTe_hat2 = (([n_BC_left; n1].*[Tae_BC_left; T_e1]).*(u_para1_half_nodes > 0) + ([n1; n_BC_right].*[T_e1; Tae_BC_right]).*(u_para1_half_nodes <= 0)); % upwinding

    % shift bounds to get flux pos/neg
    nu_hat2_pos = nu_hat2(2:end); nu_hat2_neg = nu_hat2(1:end-1);

    S_hat2_pos = S_hat2(2:end); S_hat2_neg = S_hat2(1:end-1);
    Q_hat2_pos = Q_hat2(2:end); Q_hat2_neg = Q_hat2(1:end-1);
    nTe_hat2_pos = nTe_hat2(2:end); nTe_hat2_neg = nTe_hat2(1:end-1);

    % explicitly find n via Forward Euler
    n2 = n0 + (delta*dt*An_0) - (1-delta)*(dt/dx)*(nu_hat2_pos - nu_hat2_neg);
    n2_pos = [n2(2:end); n_BC_right]; n2_neg = [n_BC_left; n2(1:end-1)];

     % ---- init y_vec, R_norm ----
    y = [n2.*u_para0; n2.*U0; T_e0];

    nu = y(1:Nx); 
    nU = y(Nx+1:2*Nx);
    T_e = y(2*Nx+1:end);
    Te_pos = [T_e(2:end); Tae_BC_right]; Te_neg = [Tae_BC_left; T_e(1:end-1)];
    nTe_pos = n2_pos.*Te_pos; nTe_neg = n2_neg.*Te_neg;

    n_pos = n2_pos; n_neg = n2_neg;
    kappa_pos = (3.2/(2*sqrt(2*me)))*((Te_pos.^(5/2) + T_e.^(5/2)));
    kappa_neg = (3.2/(2*sqrt(2*me)))*((T_e.^(5/2) + Te_neg.^(5/2))); 

    R1 = nu - (n0.*u_para0)...
            - (delta*dt*Anu_0)...
            + ((1-delta)*dt/dx)*(S_hat2_pos - S_hat2_neg) ... 
            - ((dt2*qa)/(2*dx*qe*ma)).*((n1_pos.*Te1_pos) - (n1_neg.*Te1_neg)) ...
            - ((dt1*qa)/(2*dx*qe*ma)).*((n2_pos.*Te_pos) - (n2_neg.*Te_neg));
    R2 = nU - (n0.*U0)...
            - (delta*dt*AnU_0) ...
            + ((1-delta)*dt/dx).*(Q_hat2_pos - Q_hat2_neg) ...
            - (((dt2*qa*nu1)./(2*dx*qe*n1)).*((n1_pos.*Te1_pos) - (n1_neg.*Te1_neg)))...
            - (((dt2.*3.*sqrt(2*me))./((ma.^2).*(T_e1.^(3/2)))) .* (((n1.^2).*T_e1) - ((ma/3).*((2.*n1.*nU1) - (nu1.^2))))) ...
            - (((dt1*qa*nu)./(2*dx*qe*n2)).*((n2_pos.*Te_pos) - (n2_neg.*Te_neg)))...
            - (((dt1.*3.*sqrt(2*me))./((ma.^2).*(T_e.^(3/2)))) .* (((n2.^2).*T_e) - ((ma/3).*((2.*n2.*nU) - (nu.^2)))));
    R3 = (n2.*T_e) - (n0.*T_e0) - (delta*dt*AnTe_0) + (1-delta)*dt*(5/(3*dx)).*((u_para1_half_nodes(2:end).*nTe_hat2_pos) - (u_para1_half_nodes(1:end-1).*nTe_hat2_neg)) ...
            - (((dt2*u_para1)./(3*dx)).*(nTe1_pos - nTe1_neg)) - (((2*dt2)/(3*dx.^2)) .* ((kappa1_pos.*(Te1_pos - T_e1)) - (kappa1_neg.*(T_e1 - Te1_neg)))) - (((dt2.*2.*sqrt(2*me))./(ma.*(T_e1.^(3/2)))) .* (((ma/3).*((2*n1.*nU1) - (nu1.^2))) - ((n1.^2).*T_e1))) ...
            - (((dt1*(nu./n2))./(3*dx)).*(nTe_pos - nTe_neg)) - (((2*dt1)/(3*dx.^2)) .* ((kappa_pos.*(Te_pos - T_e)) - (kappa_neg.*(T_e - Te_neg)))) - (((dt1.*2.*sqrt(2*me))./(ma.*(T_e.^(3/2)))) .* (((ma/3).*((2*n2.*nU) - (nu.^2))) - ((n2.^2).*T_e)));
    R = [R1; R2; R3];

    tol = min(5e-12, max(abs(R))*5e-10); % ensure we don't get worse!

    while max(abs(R)) > tol

        % define partial derivatives of residual
        nu_nu = spdiags(ones(Nx), 0, Nx, Nx);
        nu_nU = spdiags(zeros(Nx),0, Nx, Nx);
        nu_Te = gallery('tridiag', (dt1*qa*n2(1:end-1))/(2*dx*qe*ma), zeros(Nx,1), -(dt1*qa*n2(2:end))/(2*dx*qe*ma));
    
        nU_nu = diag( ((-dt1*qa)./(2*dx.*qe.*n2)).*((n_pos.*Te_pos) - (n_neg.*Te_neg)) );
        nU_nU = spdiags(ones(Nx), 0, Nx, Nx);
        nU_Te_mid = ((3*dt1*sqrt(2*me))./(2*(ma.^2))).*(((n2.^2)./(T_e.^(3/2))  + (ma./(T_e.^(5/2))).*((2*n2.*nU) - (nu.^2)) ));
        nU_Te = gallery('tridiag', (dt1.*qa.*nu(2:end).*(n2(1:end-1)./n2(2:end)))./(2*dx*qe), nU_Te_mid, -(dt1.*qa.*nu(1:end-1).*(n2(2:end)./n2(1:end-1)))/(2*dx*qe) );
    
        Te_nu = diag(-(dt1.*((n_pos.*Te_pos) - (n_neg.*Te_neg)))./(3*dx*n2));
        Te_nU = spdiags(zeros(Nx), 0, Nx, Nx);
        Te_Te_left = ((dt1.*nu.*n_neg)./(3*dx.*n2)) + (((dt1*3.2)./(3*(dx.^2).*sqrt(2*me))).*(((5.*(Te_neg.^(3/2))/2).*(T_e - Te_neg)) - (T_e.^(5/2) + Te_neg.^(5/2)))); Te_Te_left = Te_Te_left(2:end);
        Te_Te_mid = n2 - (((dt1*3.2)./(3*(dx.^2).*sqrt(2*me))).*(((5.*(T_e.^(3/2))./2).*(Te_pos - T_e)) - (Te_pos.^(5/2) + T_e.^(5/2)) - ((5.*(T_e.^(3/2))/2).*(T_e - Te_neg)) - (T_e.^(5/2) + Te_neg.^(5/2)))) - ((2*dt1*sqrt(2*me)./(2*ma)).*(((-ma./(T_e.^(5/2))).*(2*n2.*nU - (nu.^2)) + ((n2.^2)./(T_e.^(3/2))))));
        Te_Te_right = ((-dt1.*nu.*n_pos)./(3*dx.*n2)) - (((dt1*3.2)./(3*(dx.^2).*sqrt(2*me))).*(((5.*(Te_pos.^(3/2))/2).*(Te_pos - T_e)) + (Te_pos.^(5/2) + T_e.^(5/2)))); Te_Te_right = Te_Te_right(1:end-1);
        Te_Te = gallery('tridiag', Te_Te_left, Te_Te_mid, Te_Te_right);

        P = [nu_nu, nu_nU, nu_Te;
             nU_nu, nU_nU, nU_Te;
             Te_nu, Te_nU, Te_Te]; % holy block matrix
     
        dy = -P\R; % solve for delta y at time l+1
        y = y + dy;

        % update y_vec stuff
        nu = y(1:Nx); 
        nU = y(Nx+1:2*Nx); 
        T_e = y(2*Nx+1:end);
        Te_pos = [T_e(2:end); Tae_BC_right]; Te_neg = [Tae_BC_left; T_e(1:end-1)];
        nTe_pos = n_pos.*Te_pos; nTe_neg = n_neg.*Te_neg;

        kappa_pos = (3.2/(2*sqrt(2*me)))*((Te_pos.^(5/2) + T_e.^(5/2)));
        kappa_neg = (3.2/(2*sqrt(2*me)))*((T_e.^(5/2) + Te_neg.^(5/2)));

        R1 = nu - (n0.*u_para0) - (delta*dt*Anu_0) + ((1-delta)*dt/dx)*(S_hat2_pos - S_hat2_neg) ... 
                - ((dt2*qa)/(2*dx*qe*ma)).*((n1_pos.*Te1_pos) - (n1_neg.*Te1_neg)) ...
                - ((dt1*qa)/(2*dx*qe*ma)).*((n2_pos.*Te_pos) - (n2_neg.*Te_neg));
        R2 = nU - (n0.*U0)      - (delta*dt*AnU_0) + ((1-delta)*dt/dx).*(Q_hat2_pos - Q_hat2_neg) ...
                - (((dt2*qa*nu1)./(2*dx*qe*n1)).*((n1_pos.*Te1_pos) - (n1_neg.*Te1_neg))) - (((dt2.*3.*sqrt(2*me))./((ma.^2).*(T_e1.^(3/2)))) .* (((n1.^2).*T_e1) - ((ma/3).*((2.*n1.*nU1) - (nu1.^2))))) ...
                - (((dt1*qa*nu)./(2*dx*qe*n2)).*((n2_pos.*Te_pos) - (n2_neg.*Te_neg))) - (((dt1.*3.*sqrt(2*me))./((ma.^2).*(T_e.^(3/2)))) .* (((n2.^2).*T_e) - ((ma/3).*((2.*n2.*nU) - (nu.^2)))));
        R3 = (n2.*T_e) - (n0.*T_e0) ...
                - (delta*dt*AnTe_0) ...
                + (1-delta)*dt*(5/(3*dx)).*((u_para1_half_nodes(2:end).*nTe_hat2_pos) - (u_para1_half_nodes(1:end-1).*nTe_hat2_neg)) ...
                - (((dt2*nu1./n1)./(3*dx)).*(nTe1_pos - nTe1_neg))...
                - (((2*dt2)/(3*dx.^2)) .* ((kappa1_pos.*(Te1_pos - T_e1)) - (kappa1_neg.*(T_e1 - Te1_neg))))...
                - (((2*dt2*sqrt(2*me))./(ma.*(T_e1.^(3/2)))) .* (((ma/3).*((2*n1.*nU1) - (nu1.^2))) - ((n1.^2).*T_e1))) ...
                - (((dt1*(nu./n2))./(3*dx)).*(nTe_pos - nTe_neg))...
                - (((2*dt1)/(3*dx.^2)) .* ((kappa_pos.*(Te_pos - T_e)) - (kappa_neg.*(T_e - Te_neg)))) ...
                - (((2*dt1*sqrt(2*me))./(ma.*(T_e.^(3/2)))) .* (((ma/3).*((2*n2.*nU) - (nu.^2))) - ((n2.^2).*T_e)));
        R = [R1; R2; R3];
    end

    % return moments (yay)
    nu2 = y(1:Nx);
    nU2 = y(Nx+1:2*Nx);
    T_e2 = y(2*Nx+1:end);

    u_para2 = nu2 ./ n2;
    T_a2 = (ma/3)*(2*nU2./n2 - (nu2.^2)./(n2.^2));
    Te_all = [Tae_BC_left; T_e2; Tae_BC_right];
    kappaTx2 = (3.2/(2*sqrt(2*me)*dx))*(Te_all(1:end-1).^(2.5)+Te_all(2:end).^(2.5)).*(Te_all(2:end)-Te_all(1:end-1));
   
end

function [nu_hat, S_hat, Q_hat] = get_fluxes(f_vals_low_rank, V_perp, V_para, R_const, x_min, x_max, dx, dv_perp, dv_para)
    Nx = size(f_vals_low_rank, 1);
    [n0, u_para0, T0] = get_boundaries(x_min, x_max);

    leftBC = maxwellian(n0(x_min - dx/2), V_perp, V_para, u_para0(x_min - dx/2), T0(x_min - dx/2), R_const);
    rightBC = maxwellian(n0(x_max + dx/2), V_perp, V_para, u_para0(x_max + dx/2), T0(x_max + dx/2), R_const);

    nu_hat = zeros(Nx+1, 1);
    S_hat = zeros(Nx+1, 1);
    Q_hat = zeros(Nx+1, 1);

    v_para_split_idx = find(V_para(1, :) > 0, 1); % upwinding!
    for i = 0:Nx % loop through spatial nodes    
        f_hat = zeros(size(V_perp));
        if i == 0 % use left BC
            f_left = leftBC;
            f_right = f_vals_low_rank{i+1, 1}*f_vals_low_rank{i+1, 2}*f_vals_low_rank{i+1, 3}';
        elseif i == Nx % use right BC
            f_left = f_vals_low_rank{i, 1}*f_vals_low_rank{i, 2}*f_vals_low_rank{i, 3}';
            f_right = rightBC;
        else
            f_left = f_vals_low_rank{i, 1}*f_vals_low_rank{i, 2}*f_vals_low_rank{i, 3}';
            f_right = f_vals_low_rank{i+1, 1}*f_vals_low_rank{i+1, 2}*f_vals_low_rank{i+1, 3}';
        end
        f_hat(:, 1:v_para_split_idx-1) = f_right(:, 1:v_para_split_idx-1);
        f_hat(:, v_para_split_idx:end) = f_left(:, v_para_split_idx:end);

        nu_hat(i+1) = 2*pi*(sum(sum(V_para .* f_hat .* (V_perp.*dv_para.*dv_perp))));
        S_hat(i+1) = 2*pi*(sum(sum(V_para.^2 .* f_hat .* (V_perp.*dv_para.*dv_perp))));
        Q_hat(i+1) = pi*(sum(sum(V_para .* (V_para.^2 + V_perp.^2) .* f_hat .* (V_perp.*dv_para.*dv_perp))));
    end
end

% returns maxwellian functions for each of the Nx spatial nodes
function [f] = maxwellian(n, v_perp, v_para, u_para, T, R)
    Nx = numel(n);
    Nv = size(v_perp);
    f = zeros(Nv(1), Nv(2), Nx);
    for i = 1:Nx
        f(:, :, i) = (n(i)/((2*pi*R*T(i))^(3/2)))*exp(-((v_para-u_para(i)).^2 + v_perp.^2)/(2*R*T(i)));
    end
end

function [n0, u_para0, T_ae0] = get_boundaries(x_min, x_max)
    global n0_vals_IC u0_vals_IC T0_vals_IC;
    n0 = n0_vals_IC;
    u_para0 = u0_vals_IC;
    T_ae0 = T0_vals_IC;
end


% ------- LoMaC Truncation ------- %
function [Vr, S, Vz, rank] = LoMaC(Vr, S, Vz, Rmat, Zmat, rvals, zvals, tolerance, rhoM, JzM, kappaM, wr, wz, c, w_norm_1_squared, w_norm_v_squared, w_norm_v2_squared)
    % LoMaC Truncates given maxwellian (assumed Low-Rank) to given tolerance while conserving
    % macroscopic quantities.

    Nr = numel(rvals); Nz = numel(zvals);
    dr = rvals(2) - rvals(1);
    dz = zvals(2) - zvals(1);

    % Step 1: Integrate to calculate macro quantities
    p = 2*pi*dr*dz*sum(sum(((Vr) * S * (Vz)') .* Rmat));
    J = 2*pi*dr*dz*sum(sum(((Vr) * S * (Vz.*zvals)') .* Rmat));
    k = pi*dr*dz*sum(sum((((Vr.*(rvals.^2)) * S * Vz') + (Vr* S * ((Vz.*(zvals.^2))'))) .* Rmat));

    % Step 2: Scale by maxwellian to ensure inner product is well defined
    % (f -> 0 as v -> infinity)
    
    f1_proj_S_mtx11 = (p / w_norm_1_squared) - ((2*k - c*p)*c / w_norm_v2_squared);
    f1_proj_S_mtx12 = (J / w_norm_v_squared);
    f1_proj_S_mtx13 = ((2*k - c*p) / w_norm_v2_squared);

    proj_basis_r = wr.*[ones(Nr, 1), rvals.^2];
    proj_basis_z = wz.*[ones(Nz, 1), zvals, zvals.^2];
    f1_proj_S_mtx   = [f1_proj_S_mtx11, f1_proj_S_mtx12, f1_proj_S_mtx13;
                       f1_proj_S_mtx13,               0,               0];

    % f2 = f - f1 (do it via SVD)
    f2_U = [Vr, proj_basis_r];
    f2_S = blkdiag(S, -f1_proj_S_mtx);
    f2_V = [Vz, proj_basis_z];

    % QR factorize
    [f2_Vr, f2_S, f2_Vz, ~] = truncate(f2_U, f2_S, f2_V, rvals, tolerance);

    f2 = f2_Vr*f2_S*f2_Vz';

    % compute Pn(Te(f)) to ensure moments are kept
    trun_f2_proj_S_mtx11 = 2*pi*dr*dz*((sum(sum(f2.*Rmat)) / w_norm_1_squared) - (c*sum(sum(f2.*(Rmat.^2 + Zmat.^2 - c) .* Rmat)) / w_norm_v2_squared));
    trun_f2_proj_S_mtx12 = 2*pi*dr*dz*((sum(sum(f2.*Rmat.*Zmat))) / w_norm_v_squared);
    trun_f2_proj_S_mtx13 = 2*pi*dr*dz*((sum(sum(f2.*(Rmat.^2 + Zmat.^2 - c) .* Rmat)) / w_norm_v2_squared));

    trun_f2_proj_S_mtx   = [trun_f2_proj_S_mtx11, trun_f2_proj_S_mtx12, trun_f2_proj_S_mtx13;
                    trun_f2_proj_S_mtx13,            0,            0];

    % compute fM
    fM_proj_S_mtx11 = (rhoM / w_norm_1_squared) - ((2*kappaM - c.*rhoM)*c / w_norm_v2_squared);
    fM_proj_S_mtx12 = (JzM / w_norm_v_squared);
    fM_proj_S_mtx13 = ((2*kappaM - c*rhoM) / w_norm_v2_squared);

    fM_proj_S_mtx   = [fM_proj_S_mtx11, fM_proj_S_mtx12, fM_proj_S_mtx13;
                       fM_proj_S_mtx13,               0,              0];

    f_mass_S = fM_proj_S_mtx - trun_f2_proj_S_mtx;

    [Vr, S, Vz, rank] = truncate([proj_basis_r, f2_Vr], blkdiag(f_mass_S, f2_S), [proj_basis_z, f2_Vz], rvals, 1e-14);

end

function [Vr, S, Vz, rank] = truncate(Vr_aug, S_aug, Vz_aug, rvals, tolerance)
    [Qr, Rr] = qr2(Vr_aug, rvals); [Qz, Rz] = qr(Vz_aug, 0);
    [U, Sigma, V] = svd(Rr*S_aug*Rz', 0); 
    rank = find(diag(Sigma) > tolerance, 1, 'last');
    Vr = Qr*U(:, 1:rank);
    S = Sigma(1:rank, 1:rank);
    Vz = Qz*V(:, 1:rank);
end

function [Vr, S, Vz, rank] = truncate_svd(Vr, S, Vz, tolerance)
    [U, Sigma, V] = svd(S, 0);
    rank = find(diag(Sigma) > tolerance, 1, 'last');
    if (sum(rank) == 0)
        rank = 1;
    end
    Vr = Vr*U(:, 1:rank);
    S = Sigma(1:rank, 1:rank);
    Vz = Vz*V(:, 1:rank);
end

function [] = PlotF(f_vals_low_rank, Xmat, Rmat, Zmat2, Nz, fig_num)
    Nx = size(Xmat, 1);
    F = zeros(Nx, Nz);
    for i = 1:Nx
        f = f_vals_low_rank{i,1}*f_vals_low_rank{i,2}*f_vals_low_rank{i,3}';
        F(i,:) = 2*pi*sum(f.*Rmat, 1);
    end

    figure(fig_num); clf;
    % surf(Xmat, Zmat2, F); shading interp;
    contour(Xmat, Zmat2, F, 30,'linewidth',1.2); shading interp;
    xlabel('x');ylabel('v_{||}');view(2);colorbar;
    drawnow;
end
